import {
  SpriteSheetMetadata,
  HashSpriteSheetMetadata,
} from '@/types/export';
import { ProcessingSettings } from '@/types/processing';
import { VideoMetadata } from '@/types/video';
import { SPRITE_SHEET_METADATA_VERSION, GENERATOR_NAME } from '@/utils/constants';

const HASH_SPRITE_SHEET_VERSION = '1.0';

/**
 * Generate metadata JSON for the sprite sheet
 * Includes all processing settings for reproducibility
 */
export function generateMetadata(
  frames: ImageData[],
  settings: ProcessingSettings,
  videoMetadata: VideoMetadata | null,
  spriteSheetDimensions: {
    cols: number;
    rows: number;
  }
): string {
  const metadata: SpriteSheetMetadata = {
    version: SPRITE_SHEET_METADATA_VERSION,
    generator: GENERATOR_NAME,
    timestamp: new Date().toISOString(),
    video: videoMetadata
      ? {
          originalFPS: videoMetadata.fps,
          originalDimensions: {
            width: videoMetadata.width,
            height: videoMetadata.height,
          },
        }
      : {
          originalFPS: 30,
          originalDimensions: {
            width: 0,
            height: 0,
          },
        },
    frames: {
      count: frames.length,
      size: frames[0]?.width || 0,
    },
    processing: {
      chromaKey: {
        color: settings.chromaKey.color,
        threshold: settings.chromaKey.threshold,
        feathering: settings.chromaKey.feathering,
      },
      sizing: {
        targetSize: settings.sizing.targetSize,
        paddingReduction: settings.sizing.paddingReduction,
        anchor: settings.sizing.anchor,
      },
      haloRemoval: {
        strength: settings.haloRemoval.strength,
      },
    },
    spriteSheet: {
      columns: spriteSheetDimensions.cols,
      rows: spriteSheetDimensions.rows,
    },
  };

  return JSON.stringify(metadata, null, 2);
}

/**
 * Generate standard hash sprite sheet metadata for PixiJS/Phaser.
 * Keys are "frame_{index}.png"; each entry has frame, rotated, trimmed,
 * spriteSourceSize, and sourceSize.
 */
export function generateHashSpriteSheetMetadata(params: {
  frame_width: number;
  frame_height: number;
  columns: number;
  total_frames: number;
  output_image_name: string;
  version?: string;
}): string {
  const {
    frame_width,
    frame_height,
    columns,
    total_frames,
    output_image_name,
    version = HASH_SPRITE_SHEET_VERSION,
  } = params;

  const rows = Math.ceil(total_frames / columns);
  const totalWidth = columns * frame_width;
  const totalHeight = rows * frame_height;

  const frames: HashSpriteSheetMetadata['frames'] = {};

  for (let index = 0; index < total_frames; index++) {
    const col = index % columns;
    const row = Math.floor(index / columns);
    const x = col * frame_width;
    const y = row * frame_height;

    const key = `frame_${index}.png`;
    frames[key] = {
      frame: { x, y, w: frame_width, h: frame_height },
      rotated: false,
      trimmed: false,
      spriteSourceSize: { x: 0, y: 0, w: frame_width, h: frame_height },
      sourceSize: { w: frame_width, h: frame_height },
    };
  }

  const metadata: HashSpriteSheetMetadata = {
    frames,
    meta: {
      image: output_image_name,
      size: { w: totalWidth, h: totalHeight },
      version,
    },
  };

  return JSON.stringify(metadata, null, 2);
}

/**
 * Generate a simple README for the export
 */
export function generateReadme(
  frameCount: number,
  frameSize: number,
  spriteSheetDimensions: {
    cols: number;
    rows: number;
    width: number;
    height: number;
  }
): string {
  return `# Sprite Sheet Export

Generated by Sprite Smithy
Generated: ${new Date().toLocaleString()}

## Contents

- sprite-sheet.png: Complete sprite sheet with all frames
- frames/: Individual frame files
- sprite-smithy.json: Sprite Smithy metadata (processing settings, reproducibility)
- sprite-sheet.json: Hash-format metadata for PixiJS/Phaser (frame coordinates)

## Sprite Sheet Details

- Total Frames: ${frameCount}
- Frame Size: ${frameSize}×${frameSize}px
- Sprite Sheet Dimensions: ${spriteSheetDimensions.width}×${spriteSheetDimensions.height}px
- Grid Layout: ${spriteSheetDimensions.cols} columns × ${spriteSheetDimensions.rows} rows

## Usage

### In Game Engines

**Unity:**
1. Import sprite-sheet.png
2. Set Sprite Mode to Multiple
3. Use Sprite Editor to slice using:
   - Type: Grid By Cell Count
   - Columns: ${spriteSheetDimensions.cols}
   - Rows: ${spriteSheetDimensions.rows}

**Godot:**
1. Import sprite-sheet.png
2. Create AnimatedSprite or Sprite2D
3. Set Hframes to ${spriteSheetDimensions.cols}
4. Set Vframes to ${spriteSheetDimensions.rows}

**Phaser (with sprite-sheet.json):**
\`\`\`javascript
this.load.atlas('sprite', 'sprite-sheet.png', 'sprite-sheet.json');
// Or grid-based without JSON:
this.load.spritesheet('sprite', 'sprite-sheet.png', {
  frameWidth: ${frameSize},
  frameHeight: ${frameSize}
});
\`\`\`

## Notes

- All frames are ${frameSize}×${frameSize}px with transparency
- Frames are arranged left-to-right, top-to-bottom
- Processing was deterministic - re-processing with same settings produces identical output

---

Made with Sprite Smithy - https://github.com/anthropics/sprite-smithy
`;
}
